//Comments on the NodeScope class buried down inside the xxParser that is generated by CongoCC
// Author's name is interpolated in template as ${post.author} in index.ftl
// as as ${content.author} in page.ftl and post.ftl
:jbake:
ifdef::jbake[]
= Learning CongoCC by Examples - Part 2
Nelson Chamberlain
2022-03-13
:jbake-type: post
:jbake-tags: learning
:jbake-status: published
endif::[]
== Dissecting the NodeScope Class Inside the Parser

When you run CongoCC, it generates a parser that is based on the tokens and production rules that you defined in your grammar. At the bottom of the parser's java file is the nested class NodeScope which is used throughout the parser. In this commentary, we're going to explore how this class is used and why it is used.

Nested classes such as NodeScope are typically used for reasons that include:

*   It logically groups classes that are only used in one place, such as helper classes
*   It increases encapsulation by hiding implementation details of the nested class and preventing other classes from depending on nested class details
*   Nesting small classes within top-level classes can place the code closer to where it is used.

Nested classes can be put into two categories:

*   Static nested classes which cannot directly access instance variables of the enclosing class
*   Inner classes which can directly access the enclosing class's methods and fields. There are two special kinds of inner classes:
**  Local classes are defined in a block frequently within the body of a method
**  Anonymous classes allow you to declare and instantiate a class at the same time, many times being inserted as a parameter in the constructor of a different object.

Class NodeScope begins as follows:
----
723     @SuppressWarnings("serial")
724     class NodeScope extends ArrayList<Node>  {
725         NodeScope parentScope;
726         NodeScope() {
727             this.parentScope= Calc.this.currentNodeScope;
728             Calc.this.currentNodeScope= this;
729         }
----
Line 723 begins with @SuppressWarnings("serial") because the official Java documentation on inner classes "strongly discourages" serialization of inner classes. This annotation simply prevents an unnecessary warning being displayed.

Line 724 declares the NodeScope class as extending java.util.ArrayList and that it will hold only items of type Node. Node is an interface type generated by CongoCC. We'll look more closely at Node at some future time, but for now let's just say that it is a Swiss Army Knife kind of object, which includes:

*   implements the java.lang.Comparable interface allowing ordering of objects
*   provides methods to get Node and Token location information (getBeginLine(), getEndLine(), getBeginColumn(), etc)
*   provides default methods for managing and manipulating child and descendant nodes in document/tree-like structures
*   and lots, lots more

Line 725 declares an NodeScope instance named parentScope. When the NodeScope constructor is called (lines 726 - 729), the parentScope is set to what _had been_ the currentNodeScope and the newly constructed NodeScope object is assigned to be the currentNodeScope. In other words, when we construct a new NodeScope, we're chaining them together and the previously existing NodeScope becomes the "parent" of the newly constructed one.

And what happens when there was no previously existing NodeScope? The parentScope is a null value, which is exactly what happens the first time a NodeScope is constructed. This characteristic turns out to be very useful when looking for the root node, or the very first NodeScope in the chain, as lines 735 - 742 show below:
----
735         Node rootNode() {
736             NodeScope ns= this;
737             while (ns.parentScope!=null) {
738                 ns= ns.parentScope;
739             }
740             return ns.isEmpty()?null:
741             ns.get(0);
742         }
----
This method begins with the current NodeScope and backs up thru the chain of NodeScopes until it finds one whose parentScope is equal to null. If that NodeScope is empty then null is returned; otherwise the zeroth Node in the NodeScope's ArrayList is returned.

The chaining of NodeScopes turns out to be an extremely useful feature because it allows the Parser to manage recursive calls. Each time a new NodeScope is opened (constructed), it is "nested" inside the previous NodeScope (parent). Each nested NodeScope is a new "context", fresh and independent of any previously existing NodeScopes. When we were running the Arithmetic2 example, we saw evidence of the nesting when the AST was dumped, which indented each time nesting (openNodeScope) occurred.

Here's a sample of the dumped output:
----
(3 + (4 - 1)) * 2
Dumping the AST...
Root
  MultiplicativeExpression
    ParentheticalExpression
      (
      AdditiveExpression
        3
        +
        ParentheticalExpression
          (
          AdditiveExpression
            4
            -
            1
          )
      )
    *
    2
  EOF
The result is: 12.0
----
So let's break a long-standing rule that generated code should never be modified by hand and put in some print statements into the parser (Calc) to let us watch the sequence of events. In this particular case it's definitely OK because anytime we're done with these modifications, we can just rerun CongoCC and regenerate the parser.

Assuming you haven't changed the Arithmetic2.javacc, open ex2/Calc.java and let's start by annotating every time openNodeScope is called. Around line 200, add the println statement shown below.
----
202  if (buildTree) {
203      AdditiveExpression1= new AdditiveExpression();
204  --->System.out.println("AddExpr: call openNodeScope");
205      openNodeScope(AdditiveExpression1);
206  }
----
And then around 272, add the following printnln statement:
----
273  if (buildTree) {
274      MultiplicativeExpression2= new MultiplicativeExpression();
275  --->System.out.println("MultExpr call openNodeScope");
276      openNodeScope(MultiplicativeExpression2);
277  }
----
And around line 361, add the following println statement:
----
366  if (buildTree) {
367      ParentheticalExpression3= new ParentheticalExpression();
368  --->System.out.println("ParenExpr call openNodeScope");
369      openNodeScope(ParentheticalExpression3);
370  }
----
And finally around line 410 add the following println statement:
----

415  if (buildTree) {
416      Root4= new Root();
417  --->System.out.println("Root call openNodeScope");
418      openNodeScope(Root4);
419  }
----
Now let's announce everytime that a Token is consumed. Around line 552, add the following println statement:
----
552  System.out.println("consumeToken: " + nextToken.getImage());
----
Next, let's add some lines to the openNodeScope method itself, around line 654:
----

654  String s = "unassigned 1";
655  if (lastConsumedToken == null) {
656      s = "lastConsumedToken == null" ;
657  } else {
658      s = "lastConsumedToken == " + lastConsumedToken.getImage();
659  }
660  System.out.println("openNodeScope: " + s) ;
----
Now let's add println statements to both of the closeNodeScope methods. Around line 669, add the following statement:
----
671  System.out.println("closeNodeScope(Node, int) called for Token " +
672  lastConsumedToken.getImage() + " at " + lastConsumedToken.getEndOffset());
----
The second closeNodeScope method has a boolean as the second parameter and it seems to be the only close method used in this example. This second closeNodeScope method needs println statements in two places, around the lines shown following:
----
697  System.out.println("closeNodeScope(Node, boolean) called for Token " +
698  lastConsumedToken.getImage() + " Ending at " + lastConsumedToken.getEndOffset());
. . . .
722  else  {
723        System.out.println("closeNodeScope(Node, boolean) else Token =  " +
724            lastConsumedToken.getImage() + " ending at " + lastConsumedToken.getEndOffset());
725    currentNodeScope.close();
726  }
----

And finally, let's do add a line that will make the beginning status a little more clear, as follows:
----
111  lastConsumedToken.setImage("DUMMY_START_TOKEN");
----
Save and exit the updated Calc.java file and then run the following two commands in the terminal window:
----
javac ex2/*.java
java ex2/Calc
----
If everything was entered correctly, it should have compiled without complaints and when you run ex2/Cacl, the cursor will advance to the next line and wait for you to input a mathematical expression for it to parse and evaluate. Let's try something very simple
such as:
----
123
Root call openNodeScope
openNodeScope: lastConsumedToken == DUMMY_START_TOKEN
AddExpr: call openNodeScope
openNodeScope: lastConsumedToken == DUMMY_START_TOKEN
MultExpr call openNodeScope
openNodeScope: lastConsumedToken == DUMMY_START_TOKEN
consumeToken: 123
closeNodeScope(Node, boolean) else Token =  123 ending at 3
closeNodeScope(Node, boolean) else Token =  123 ending at 3
consumeToken:
closeNodeScope(Node, boolean) called for Token  Ending at 3
Dumping the AST...
Root
  123
  EOF
The result is: 123.0
----
We entered a number all by itself, with no operators or parentheses. When we pressed enter, the Root production rule was called which called the openNodeScope method which now printed the information that the lastConsumedToken was DUMMY_START_TOKEN. The value of DUMMY_START_TOKEN was set in the last line that we added, where we called setImage so LastConsumedToken would have something to print (borrowing the contents from the constructor that uses lexer.DUMMY_START_TOKEN).

The first thing the Root production rule does is call the AdditiveExpression production rule, which also calls openNodeScope. Because we haven't consumed any input so far, the message again refers to DUMMY_START_TOKEN. Inside the AdditiveExpression production rule it goes on to call the MultiplicativeExpression, which itself calls the openNodeScope method. And since we still haven't consumed any Tokens, it again reports that lastConsumedToken == DUMMY_START_TOKEN.

Next we consume a <NUMBER> Token, this one with a value of 123. There is nothing else for it to do so it closes the current NodeScope, which causes the previous NodeScope to close.

At this point, there is no additional input to consume, which CongoCC helpfully interpreted as EOF (end of file) which allows the Root production rule to complete and call closeNodeScope with an empty Token image. At this point, the main function resumes and dumps the AST.

Time to start messing around with this annotated code. Give it more complicated math expressions to parse and evaluate (calc the value). Give it lots of parentheses to work with, such as:
----
(((((456+234-123+789)))))
Root call openNodeScope
openNodeScope: lastConsumedToken == DUMMY_START_TOKEN
AddExpr: call openNodeScope
openNodeScope: lastConsumedToken == DUMMY_START_TOKEN
MultExpr call openNodeScope
openNodeScope: lastConsumedToken == DUMMY_START_TOKEN
ParenExpr call openNodeScope
openNodeScope: lastConsumedToken == DUMMY_START_TOKEN
consumeToken: (
AddExpr: call openNodeScope
openNodeScope: lastConsumedToken == (
MultExpr call openNodeScope
openNodeScope: lastConsumedToken == (
ParenExpr call openNodeScope
openNodeScope: lastConsumedToken == (
consumeToken: (
AddExpr: call openNodeScope
openNodeScope: lastConsumedToken == (
MultExpr call openNodeScope
openNodeScope: lastConsumedToken == (
ParenExpr call openNodeScope
openNodeScope: lastConsumedToken == (
consumeToken: (
. . .
            (
            AdditiveExpression
              456
              +
              234
              -
              123
              +
              789
            )
          )
        )
      )
    )
  EOF
The result is: 1356.0
----
We can see how every time it hits an OPEN_PAREN it calls openNodeScope, opening up a fresh working environment until it finally hits some <NUMBER> and add/subtract operators which are all included in the innermost context (NodeScope). It remains in the same NodeScope until it reaches a CLOSE_PAREN and closes the currentNodeScope. If it had reached a times or divide operator instead of the CLOSE_PAREN, a new openNodeScope would be called to handle these multiplicative operators.

Fun stuff. When you're done with these annotations, you can delete everything in ex2 folder because you can regenerate the regular code anytime you want.

Next, we'll look at States and State Diagrams.